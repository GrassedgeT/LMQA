# 项目技术方案分析文档

浏览器-服务器架构，前端包含一些用户注册、登录、问题对话框输入、回答等功能，也包含记忆数据管理、展示功能，服务器后端包含Agent执行、数据管理、结果返回等功能。
要求使用python主流的前后端框架。

## 一、项目需求分析

### 1.1 核心功能模块

#### 1.1.1 用户认证功能
**前端需求：**
- 用户注册页面（用户名、邮箱、密码输入）
- 用户登录页面（用户名/邮箱、密码输入）
- 登录状态管理（Token存储、自动登录）
- 用户信息展示

**后端需求：**
- 用户注册接口（验证、密码加密、用户创建）
- 用户登录接口（验证、Token生成）
- Token验证中间件
- 用户信息查询接口

#### 1.1.2 对话交互功能
**前端需求：**
- 对话列表（显示所有对话会话）
- 对话窗口（消息输入框、消息展示区域）
- 实时消息显示（流式或非流式）
- 对话历史记录（滚动加载、分页）
- 新建对话、删除对话

**后端需求：**
- 创建对话接口
- 发送消息接口（接收用户问题，调用智能体，返回回答）
- 获取对话列表接口
- 获取对话历史接口
- 删除对话接口
- 与智能体服务的接口交互（调用智能体API，传递上下文）

#### 1.1.3 记忆数据管理功能
**前端需求：**
- 记忆列表展示（卡片式或列表式）
- 记忆搜索（关键词搜索、语义搜索）
- 记忆分类筛选（按类型、标签筛选）
- 记忆编辑（创建、修改、删除）
- 记忆详情查看

**后端需求：**
- 获取记忆列表接口（支持分页、筛选、搜索）
- 创建记忆接口
- 更新记忆接口
- 删除记忆接口
- 搜索记忆接口（关键词搜索、语义搜索）
- 与智能体服务的接口交互（同步记忆数据）

### 1.2 系统架构概述

```
前端 (React + Vite) ←→ HTTP/RESTful API ←→ 后端 (Flask) ←→ 智能体服务 (Agent Service)
                        ↓
                    数据库 (SQLite/PostgreSQL)
```

**关键点：**
- 前端通过RESTful API与后端通信
- 后端作为中间层，处理业务逻辑和数据管理
- 后端通过接口调用智能体服务（智能体内部使用Mem0、FastMCP）
- 智能体内部实现细节对前后端透明
- **当前实现**：开发环境使用SQLite，生产环境可切换到PostgreSQL

---

## 二、技术框架选型

### 2.1 后端框架选择

#### 推荐方案：Flask（已实现）

**选择理由：**
- **成熟稳定**：Flask是Python最主流、最成熟的轻量级Web框架之一，社区活跃，文档完善
- **灵活性强**：微框架设计，可以根据需求灵活选择组件，适合集成AI Agent
- **易于扩展**：插件生态丰富，可以轻松集成数据库、认证、API等功能
- **学习曲线平缓**：相比Django更轻量，上手快
- **适合AI项目**：与Python AI库（如OpenAI SDK）集成方便

**实际实现的核心组件：**
- `Flask`：核心Web框架 ✅
- `Flask-CORS`：跨域支持 ✅
- `PyJWT`：JWT认证（替代Flask-JWT-Extended，更轻量）✅
- `Werkzeug`：密码加密（generate_password_hash, check_password_hash）✅
- `SQLite3`：开发环境数据库（生产环境可切换到PostgreSQL）✅
- `Requests`：HTTP请求（用于调用外部智能体服务）✅

**说明：**
- 当前实现使用原生Flask路由，未使用Flask-RESTful（保持代码简洁）
- 使用PyJWT直接处理JWT，而非Flask-JWT-Extended（减少依赖）
- 开发环境使用SQLite，生产环境建议使用PostgreSQL


### 2.2 前端框架选择

#### 推荐方案：React + TypeScript

**选择理由：**
- **主流成熟**：React是当前最主流的前端框架，生态完善
- **组件化开发**：适合构建复杂的交互界面
- **状态管理**：可以使用Redux或Zustand管理应用状态
- **UI组件库**：丰富的UI库（Ant Design、Material-UI等）
- **TypeScript支持**：类型安全，提高代码质量

**实际实现的技术栈：**
- `React 19+`：前端框架 ✅
- `TypeScript`：类型系统 ✅
- `React Router DOM`：路由管理 ✅
- `Fetch API`：HTTP请求（原生API，无需Axios）✅
- `Vite`：构建工具和开发服务器 ✅
- `react-markdown`：Markdown渲染 ✅
- `react-syntax-highlighter`：代码高亮 ✅
- `CSS Modules`：样式管理 ✅
- **无UI组件库**：使用自定义CSS实现DeepSeek风格的UI ✅

**说明：**
- 使用Vite替代Create React App，构建速度更快
- 使用原生Fetch API替代Axios，减少依赖
- 未使用UI组件库，完全自定义UI以匹配DeepSeek风格
- 使用CSS变量实现主题切换

#### 备选方案：Vue 3 + TypeScript

**适用场景：**
- 团队更熟悉Vue生态
- 需要更简单的学习曲线

### 2.2.1 前端UI/UX设计（参考ChatGPT、Qwen等知名大模型网页）

#### 整体布局设计

**参考设计：** ChatGPT、Qwen、Claude等主流AI对话界面

**核心布局：**
```
┌─────────────────────────────────────────────────┐
│  顶部导航栏（Logo、用户信息、设置）                  │
├──────────┬──────────────────────────────────────┤
│          │                                      │
│  侧边栏   │        主对话区域                      │
│  (左侧)   │        - 消息列表                    │
│          │        - 消息气泡                     │
│ - 对话列表│        - Markdown渲染                 │
│ - 新建对话│        - 代码高亮                     │
│ - 搜索    │        - 流式输出动画                 │
│ - 记忆管理│                                      │
│          │                                      │
│          ├──────────────────────────────────────┤
│          │  输入区域                              │
│          │  - 多行输入框                         │
│          │  - 发送按钮                           │
│          │  - 附件上传                           │
│          │  - 快捷操作按钮                       │
└──────────┴──────────────────────────────────────┘
```

#### 主要页面设计

**1. 登录/注册页面**
- **设计风格**：简洁、现代、居中布局
- **参考**：ChatGPT登录页、Qwen登录页
- **元素**：
  - 品牌Logo和标语
  - 表单输入框（用户名/邮箱、密码）
  - 登录/注册按钮
  - 忘记密码链接
  - 第三方登录选项（可选）

**2. 主对话页面（核心页面）**

**左侧边栏：**
- **对话列表**：
  - 可折叠/展开
  - 显示对话标题和最后消息预览
  - 支持搜索对话
  - 支持删除、重命名对话
  - 新建对话按钮（固定在顶部）
  - 滚动加载更多对话

- **记忆管理入口**：
  - 记忆列表快捷入口
  - 显示记忆数量统计

**主对话区域：**
- **消息展示区**：
  - 用户消息：右侧对齐，浅色背景
  - AI消息：左侧对齐，深色背景
  - 支持Markdown渲染（标题、列表、代码块、表格等）
  - 代码高亮显示
  - 消息时间戳（悬停显示）
  - 消息操作按钮（复制、删除、重新生成）
  - 流式输出时的打字动画效果
  - 加载状态指示器

- **输入区域**：
  - 多行文本输入框（支持自动扩展高度）
  - 占位符提示文字
  - 发送按钮（支持Ctrl+Enter快捷键）
  - 附件上传按钮（图片、文件等）
  - 快捷操作按钮（清空、停止生成等）
  - 输入字数统计（可选）

**3. 记忆管理页面**

**布局设计：**
- **顶部工具栏**：
  - 搜索框（支持关键词和语义搜索）
  - 筛选器（按分类、标签、类型筛选）
  - 新建记忆按钮
  - 视图切换（列表视图/卡片视图）

- **记忆展示区**：
  - **卡片视图**（默认）：
    - 卡片式布局，每行2-3个卡片
    - 显示标题、内容预览、分类、标签
    - 悬停显示操作按钮（编辑、删除）
    - 点击查看详情
  
  - **列表视图**：
    - 表格形式展示
    - 可排序（按时间、标题等）
    - 批量操作支持

- **记忆详情/编辑**：
  - 模态框或侧边栏形式
  - 标题、内容、分类、标签编辑
  - 保存、取消按钮

#### UI组件设计规范

**颜色方案：**
- **主色调**：深色模式为主（参考ChatGPT深色主题）
  - 背景色：`#212121` 或 `#1a1a1a`
  - 卡片背景：`#2d2d2d`
  - 文本色：`#ffffff` / `#e0e0e0`
  - 主色：`#10a37f`（绿色系，参考ChatGPT）或 `#6366f1`（紫色系）
  - 强调色：`#3b82f6`（蓝色）
  - 错误色：`#ef4444`（红色）
  - 警告色：`#f59e0b`（橙色）

- **浅色模式**（可选）：
  - 背景色：`#ffffff`
  - 卡片背景：`#f5f5f5`
  - 文本色：`#1a1a1a`

**字体规范：**
- **主字体**：系统字体栈（-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto等）
- **代码字体**：Monaco, "Courier New", monospace
- **字号**：
  - 标题：16px-20px
  - 正文：14px-16px
  - 辅助文字：12px-14px

**间距规范：**
- **卡片内边距**：16px-24px
- **元素间距**：8px、12px、16px、24px
- **页面边距**：16px-32px

**交互效果：**
- **按钮悬停**：背景色变化、轻微阴影
- **卡片悬停**：轻微上浮效果（transform: translateY(-2px)）
- **加载动画**：骨架屏或脉冲动画
- **过渡动画**：0.2s-0.3s ease-in-out

#### 响应式设计

**断点设置：**
- **移动端**：< 768px
  - 侧边栏隐藏，通过菜单按钮打开
  - 单列布局
  - 触摸友好的按钮尺寸

- **平板**：768px - 1024px
  - 侧边栏可折叠
  - 双列布局

- **桌面端**：> 1024px
  - 完整布局
  - 侧边栏默认展开

#### 关键交互特性

**1. 流式输出体验：**
- 实时显示AI生成的内容
- 打字动画效果
- 支持停止生成
- 生成完成后显示完整消息

**2. 消息操作：**
- 复制消息内容
- 重新生成回答
- 编辑用户消息（重新发送）
- 删除消息

**3. 对话管理：**
- 拖拽排序对话（可选）
- 批量删除对话
- 对话重命名
- 对话导出（可选）

**4. 记忆管理：**
- 快速创建记忆（从对话中提取）
- 记忆关联到对话
- 记忆搜索高亮
- 记忆标签云展示

#### UI组件库选择

**推荐方案：**
- **Ant Design**：组件丰富，适合企业级应用
- **shadcn/ui**：现代化设计，高度可定制
- **Tailwind CSS**：实用优先的CSS框架，快速开发

**自定义组件：**
- 消息气泡组件
- 流式输出组件
- 代码高亮组件（使用react-syntax-highlighter）
- Markdown渲染组件（使用react-markdown）

---

### 2.3 数据库选择

#### 当前实现：SQLite（开发环境）

**实际使用：**
- **开发环境**：SQLite ✅（已实现）
- **生产环境**：建议使用PostgreSQL（可配置切换）

**选择SQLite的理由（开发阶段）：**
- **零配置**：无需安装和配置数据库服务器
- **轻量级**：单文件数据库，易于备份和迁移
- **快速开发**：适合快速原型开发和测试
- **功能完整**：支持所有必需的SQL功能

**数据表设计（已实现）：**
1. **users表**：用户基本信息 ✅
2. **conversations表**：对话会话 ✅
3. **messages表**：对话消息记录 ✅
4. **memories表**：用户记忆数据 ✅

**生产环境建议：**
- 切换到PostgreSQL以获得更好的性能和并发支持
- 支持向量扩展（pgvector），适合未来AI功能扩展
- 通过环境变量`DATABASE`配置数据库路径（SQLite）或连接字符串（PostgreSQL）

---

### 2.4 智能体服务框架

**说明：** 智能体服务作为接口适配层，支持两种工作模式：
1. **外部智能体服务模式**：如果配置了`AGENT_SERVICE_URL`，则通过HTTP接口调用本地部署的外部智能体服务
   - 外部智能体服务是独立部署的本地服务（如 `http://localhost:8000`）
   - 未来可能集成到本项目，当前通过HTTP接口调用
   - 已预留集成接口，方便未来集成
2. **本地智能体模式**：使用本地LLM客户端（OpenAI/DeepSeek）和Mem0框架

**智能体服务内部框架：**
- **Mem0**：智能记忆管理，负责长期记忆的存储和检索（必须保留）
- **FastMCP**：上下文管理协议，负责会话上下文的传递和管理（可选）
- **LLM提供商**：支持OpenAI和DeepSeek API（兼容OpenAI API格式）

**后端与智能体服务的交互方式：**

#### 模式1：外部智能体服务（本地部署）

```python
# 后端通过HTTP接口调用本地部署的外部智能体服务
class AgentService:
    def process_message(self, user_id, conversation_id, message, context):
        # 如果配置了AGENT_SERVICE_URL，调用外部服务（本地部署的独立服务）
        if self.agent_service_url:
            return self._call_external_agent_service(user_id, conversation_id, message, context)
        
        # 如果未来集成到项目中，可以改为直接调用内部方法
        # if self.agent_integrated:
        #     return self._process_message_integrated(user_id, conversation_id, message, context)
        
        # 否则使用本地实现
        return self._process_message_local(user_id, conversation_id, message, context)
    
    def _call_external_agent_service(self, user_id, conversation_id, message, context):
        # HTTP POST请求到本地部署的外部智能体服务（如 http://localhost:8000）
        response = requests.post(
            f"{self.agent_service_url}/process",
            json={'user_id': user_id, 'conversation_id': conversation_id, 
                  'message': message, 'context': context}
        )
        return response.json().get('assistant_message', '')
    
    def _process_message_integrated(self, user_id, conversation_id, message, context):
        """
        集成模式处理消息（预留接口）
        
        说明：
        - 当外部智能体服务集成到本项目后，使用此方法
        - 可以直接调用集成后的智能体模块，无需HTTP请求
        """
        # TODO: 实现集成模式
        # from app.agent_service import integrated_agent
        # return integrated_agent.process(user_id, conversation_id, message, context)
        pass
```

**外部智能体服务接口规范（本地部署）：**
- **服务地址**：本地部署的独立服务（如 `http://localhost:8000`）
- **接口列表**：
  - `POST /process`：处理消息，返回完整回答
  - `POST /process/stream`：流式处理消息，返回SSE流
  - `POST /memories/sync`：同步记忆到Mem0
  - `POST /memories/search`：语义搜索记忆
  - `DELETE /memories/{mem0_memory_id}`：删除记忆

**集成接口预留：**
- 已创建 `backend/app/agent_service_interface.py` 定义接口规范
- 已预留 `_process_message_integrated` 和 `_process_message_stream_integrated` 方法
- 集成步骤：
  1. 将外部智能体服务代码移动到 `backend/app/agent_service/` 目录
  2. 实现 `AgentServiceInterface` 接口
  3. 设置 `AGENT_INTEGRATED=true` 启用集成模式
  4. 修改 `AgentService` 调用集成后的服务

#### 模式2：本地智能体实现

```python
# 本地实现（使用LLM客户端和Mem0）
class AgentService:
    def _process_message_local(self, user_id, conversation_id, message, context):
        # 1. 通过Mem0检索相关记忆
        relevant_memories = self.mem0_client.search(user_id, message, limit=5)
        
        # 2. 构建消息列表（包含系统提示、历史消息、相关记忆、当前消息）
        messages = build_messages(context, relevant_memories, message)
        
        # 3. 调用LLM生成回答（支持OpenAI和DeepSeek）
        response = self.llm_client.chat.completions.create(
            model=self.llm_model,
            messages=messages
        )
        
        # 4. 通过Mem0存储新记忆（可选）
        if should_store_memory(response):
            self.mem0_client.add_memory(user_id, memory_data)
        
        return response.choices[0].message.content
```

**LLM提供商支持：**
- **OpenAI**：使用官方OpenAI API
- **DeepSeek**：使用DeepSeek API（兼容OpenAI API格式）
- 通过`LLM_PROVIDER`环境变量切换（`openai`或`deepseek`）

**关键点：**
- 后端通过统一的接口适配层调用智能体服务
- 支持外部智能体服务（本地部署）和本地实现两种模式
- 外部智能体服务是本地部署的独立服务，未来可能集成到项目
- 已预留集成接口，方便未来将外部智能体服务集成到项目中
- 外部智能体服务应实现Mem0和FastMCP，对后端透明
- 本地模式支持OpenAI和DeepSeek两种LLM提供商
- Mem0框架必须保留，用于记忆管理

---

## 三、系统架构设计

### 3.1 整体架构

```
┌─────────────────────────────────────────┐
│        前端层 (React + TypeScript)       │
│  - 用户界面组件（认证、对话、记忆管理）      │
│  - 状态管理 (Redux/Zustand)             │
│  - API服务层（封装HTTP请求）             │
└──────────────┬──────────────────────────┘
               │
               │ HTTP/HTTPS RESTful API
               │
┌──────────────▼──────────────────────────┐
│        后端层 (Flask + Flask-RESTful)    │
│  ┌──────────────────────────────────┐   │
│  │ API路由层                        │   │
│  │ - /api/auth/* (认证接口)         │   │
│  │ - /api/conversations/* (对话接口) │   │
│  │ - /api/memories/* (记忆接口)     │   │
│  └──────────────┬───────────────────┘   │
│                 │                       │
│  ┌──────────────▼───────────────────┐   │
│  │ 业务逻辑层                        │   │
│  │ - 用户管理服务                    │   │
│  │ - 对话管理服务                    │   │
│  │ - 记忆管理服务                    │   │
│  │ - 智能体服务接口调用              │   │
│  └──────────────┬───────────────────┘   │
│                 │                       │
│  ┌──────────────▼───────────────────┐   │
│  │ 数据访问层                        │   │
│  │ - ORM模型（SQLAlchemy）           │   │
│  │ - 数据库操作                      │   │
│  └──────────────────────────────────┘   │
└──────────────┬──────────────────────────┘
               │
    ┌──────────┴──────────┐
    │                      │
┌───▼────┐        ┌───────▼──────┐
│PostgreSQL│      │  智能体服务    │
│关系数据库 │      │ (内部实现)    │
│          │      │              │
│- users   │      │              │
│- convs   │      │ - Mem0       │
│- msgs    │      │ - FastMCP    │
│- memories│      │              │
│- contexts│      │ (对前后端透明)│
└──────────┘      └──────────────┘
```

**架构说明：**

1. **前端层**：
   - React应用，负责用户界面和交互
   - 通过API服务层调用后端接口
   - 管理前端状态和路由

2. **后端API层**：
   - Flask RESTful API，提供标准HTTP接口
   - 处理请求验证、数据序列化、错误处理
   - 实现认证授权（JWT）

3. **后端业务逻辑层**：
   - 处理业务逻辑和数据验证
   - 调用智能体服务接口
   - 管理数据持久化

4. **数据存储层**：
   - PostgreSQL：存储所有结构化数据（用户、对话、消息、记忆元数据等）
   - 智能体服务内部使用向量数据库等（对前后端透明）

5. **智能体服务**：
   - 独立服务模块，内部使用Mem0、FastMCP
   - 通过接口与后端通信
   - 对前后端透明，后端只需调用其接口

### 3.2 目录结构设计

```
project/
├── backend/                      # 后端代码
│   ├── app/
│   │   ├── __init__.py          # Flask应用初始化
│   │   ├── models/              # 数据模型
│   │   │   ├── user.py
│   │   │   ├── conversation.py
│   │   │   ├── message.py
│   │   │   └── memory.py
│   │   ├── routes/              # API路由
│   │   │   ├── auth.py          # 认证相关
│   │   │   ├── conversation.py
│   │   │   └── memory.py
│   │   ├── services/            # 业务逻辑服务
│   │   │   ├── user_service.py  # 用户管理服务
│   │   │   ├── conversation_service.py  # 对话管理服务
│   │   │   ├── memory_service.py       # 记忆管理服务
│   │   │   └── agent_service.py        # 智能体服务接口调用
│   │   ├── utils/               # 工具函数
│   │   │   ├── auth.py
│   │   │   ├── database.py
│   │   │   └── validators.py
│   │   └── config.py            # 配置文件
│   ├── agent_service/            # 智能体服务（独立模块，可选）
│   │   ├── __init__.py
│   │   ├── agent.py             # Agent主服务接口
│   │   └── config.py            # 智能体配置（内部实现）
│   ├── requirements.txt         # Python依赖
│   ├── .env.example            # 环境变量示例
│   └── run.py                  # 启动文件
│
├── frontend/                    # 前端代码
│   ├── src/
│   │   ├── components/         # React组件
│   │   │   ├── Auth/
│   │   │   │   ├── Login.tsx
│   │   │   │   └── Register.tsx
│   │   │   ├── Chat/
│   │   │   │   ├── ChatWindow.tsx
│   │   │   │   ├── MessageList.tsx
│   │   │   │   └── MessageInput.tsx
│   │   │   └── Memory/
│   │   │       ├── MemoryList.tsx
│   │   │       ├── MemoryCard.tsx
│   │   │       └── MemoryEditor.tsx
│   │   ├── services/           # API服务
│   │   │   ├── api.ts          # API客户端
│   │   │   ├── authService.ts
│   │   │   ├── conversationService.ts
│   │   │   └── memoryService.ts
│   │   ├── store/              # 状态管理
│   │   │   ├── slices/
│   │   │   │   ├── authSlice.ts
│   │   │   │   ├── chatSlice.ts
│   │   │   │   └── memorySlice.ts
│   │   │   └── store.ts
│   │   ├── hooks/              # 自定义Hooks
│   │   │   ├── useAuth.ts
│   │   │   └── useWebSocket.ts
│   │   ├── utils/              # 工具函数
│   │   │   ├── constants.ts
│   │   │   └── helpers.ts
│   │   ├── types/              # TypeScript类型定义
│   │   │   ├── api.ts
│   │   │   └── models.ts
│   │   └── App.tsx
│   ├── package.json
│   ├── tsconfig.json
│   └── .env.example
│
├── database/                    # 数据库相关
│   ├── migrations/             # 数据库迁移文件
│   └── seeds/                  # 种子数据
│
└── docs/                       # 文档
    ├── api/                    # API文档
    └── architecture/           # 架构文档
```

---

## 四、数据库设计

### 4.1 用户表 (users)

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    avatar_url VARCHAR(500),              -- 头像URL
    bio TEXT,                             -- 个人简介
    is_active BOOLEAN DEFAULT TRUE,       -- 账户是否激活
    is_email_verified BOOLEAN DEFAULT FALSE, -- 邮箱是否验证
    last_login_at TIMESTAMP,              -- 最后登录时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
```

**字段说明：**
- `id`：主键，自增
- `username`：用户名，唯一，3-50个字符
- `email`：邮箱，唯一，用于登录和通知
- `password_hash`：加密后的密码（使用bcrypt，至少8个字符）
- `avatar_url`：用户头像URL（可选）
- `bio`：个人简介（可选）
- `is_active`：账户是否激活，默认true
- `is_email_verified`：邮箱是否验证，默认false
- `last_login_at`：最后登录时间，用于统计和安全性
- `created_at`：创建时间
- `updated_at`：更新时间

### 4.2 对话会话表 (conversations)

```sql
CREATE TABLE conversations (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(200),                    -- 对话标题（自动生成或手动设置）
    description TEXT,                      -- 对话描述（可选）
    is_pinned BOOLEAN DEFAULT FALSE,      -- 是否置顶
    is_archived BOOLEAN DEFAULT FALSE,    -- 是否归档
    message_count INTEGER DEFAULT 0,       -- 消息数量（冗余字段，用于快速查询）
    last_message_at TIMESTAMP,             -- 最后消息时间
    settings JSONB,                        -- 对话设置（JSON格式，如模型参数等）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_conversations_user_id ON conversations(user_id);
CREATE INDEX idx_conversations_user_updated ON conversations(user_id, updated_at DESC);
CREATE INDEX idx_conversations_pinned ON conversations(user_id, is_pinned, updated_at DESC);
```

**字段说明：**
- `id`：主键
- `user_id`：外键，关联用户
- `title`：对话标题，如果为空则自动从第一条消息生成
- `description`：对话描述（可选）
- `is_pinned`：是否置顶，置顶的对话显示在列表顶部
- `is_archived`：是否归档，归档的对话不显示在默认列表中
- `message_count`：消息数量，冗余字段用于快速统计
- `last_message_at`：最后消息时间，用于排序
- `settings`：对话设置，JSON格式存储（如使用的模型、温度参数等）
- `created_at`：创建时间
- `updated_at`：最后更新时间

### 4.3 消息表 (messages)

```sql
CREATE TABLE messages (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL,            -- 'user' 或 'assistant' 或 'system'
    content TEXT NOT NULL,                -- 消息内容（支持Markdown）
    parent_message_id INTEGER REFERENCES messages(id), -- 父消息ID（用于消息树结构）
    tokens INTEGER,                       -- Token数量（用于统计和计费）
    is_edited BOOLEAN DEFAULT FALSE,      -- 是否被编辑过
    edited_at TIMESTAMP,                  -- 编辑时间
    metadata JSONB,                       -- 消息元数据（JSON格式，如生成参数、模型版本等）
    attachments JSONB,                    -- 附件信息（JSON数组，存储文件URL、类型等）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_messages_conversation ON messages(conversation_id, created_at);
CREATE INDEX idx_messages_parent ON messages(parent_message_id);
CREATE INDEX idx_messages_role ON messages(conversation_id, role);
```

**字段说明：**
- `id`：主键
- `conversation_id`：外键，关联对话会话
- `role`：消息角色（'user'、'assistant'、'system'）
- `content`：消息内容，支持Markdown格式
- `parent_message_id`：父消息ID，用于支持消息树结构（如重新生成、分支对话）
- `tokens`：Token数量，用于统计和计费
- `is_edited`：是否被编辑过
- `edited_at`：编辑时间
- `metadata`：消息元数据，JSON格式（如模型版本、生成参数、响应时间等）
- `attachments`：附件信息，JSON数组格式（如文件URL、类型、大小等）
- `created_at`：创建时间
- `updated_at`：更新时间

### 4.4 记忆数据表 (memories)

```sql
CREATE TABLE memories (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    mem0_memory_id VARCHAR(100),  -- Mem0框架生成的记忆ID
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    memory_type VARCHAR(50),  -- 记忆类型：working, factual, episodic, semantic
    category VARCHAR(50),     -- 分类标签
    tags TEXT[],              -- 标签数组
    metadata JSONB,           -- 存储Mem0的元数据（JSON格式）
    vector_id VARCHAR(100),   -- 向量数据库中的ID（如果使用外部向量库）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_memories_user_id ON memories(user_id);
CREATE INDEX idx_memories_mem0_id ON memories(mem0_memory_id);
CREATE INDEX idx_memories_type ON memories(memory_type);
CREATE INDEX idx_memories_category ON memories(category);
CREATE INDEX idx_memories_metadata ON memories USING GIN(metadata);  -- GIN索引用于JSONB查询
```

**字段说明：**
- `id`：主键
- `user_id`：外键，关联用户
- `mem0_memory_id`：Mem0框架生成的唯一记忆ID，用于与Mem0系统关联
- `title`：记忆标题
- `content`：记忆内容
- `memory_type`：记忆类型（工作记忆、事实记忆、情景记忆、语义记忆）
- `category`：分类
- `tags`：标签数组（PostgreSQL数组类型）
- `metadata`：Mem0的元数据，以JSON格式存储（如重要性评分、关联实体等）
- `vector_id`：向量数据库中的ID，用于关联向量嵌入
- `created_at`：创建时间
- `updated_at`：更新时间

**注意：**
- Mem0的实际向量嵌入存储在向量数据库（Qdrant/Pinecone等）中
- 此表主要用于存储记忆的元数据和与Mem0的关联
- 如果使用PostgreSQL的pgvector扩展，也可以在此表中直接存储向量

### 4.5 用户会话表 (user_sessions)

```sql
CREATE TABLE user_sessions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL,     -- Token哈希值（用于撤销token）
    device_info VARCHAR(200),              -- 设备信息（浏览器、操作系统等）
    ip_address VARCHAR(45),                -- IP地址（IPv4或IPv6）
    user_agent TEXT,                      -- User-Agent字符串
    is_active BOOLEAN DEFAULT TRUE,       -- 会话是否活跃
    expires_at TIMESTAMP NOT NULL,
    last_activity_at TIMESTAMP,           -- 最后活动时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sessions_user ON user_sessions(user_id, is_active);
CREATE INDEX idx_sessions_expires ON user_sessions(expires_at);
```

**字段说明：**
- `id`：主键
- `user_id`：外键，关联用户
- `token_hash`：Token哈希值，用于撤销特定token（JWT本身无状态，但可以记录哈希用于黑名单）
- `device_info`：设备信息（如"Chrome on Windows"）
- `ip_address`：IP地址，用于安全审计
- `user_agent`：User-Agent字符串，用于设备识别
- `is_active`：会话是否活跃，可以手动禁用
- `expires_at`：过期时间
- `last_activity_at`：最后活动时间，用于清理不活跃会话
- `created_at`：创建时间

### 4.6 MCP上下文表 (mcp_contexts)

```sql
CREATE TABLE mcp_contexts (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    context_type VARCHAR(50) NOT NULL,  -- 'session', 'user', 'system'
    context_data JSONB NOT NULL,         -- 上下文数据（JSON格式）
    expires_at TIMESTAMP,                -- 上下文过期时间（可选）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_mcp_contexts_conversation ON mcp_contexts(conversation_id);
CREATE INDEX idx_mcp_contexts_type ON mcp_contexts(context_type);
CREATE INDEX idx_mcp_contexts_data ON mcp_contexts USING GIN(context_data);
```

**字段说明：**
- `id`：主键
- `conversation_id`：外键，关联对话会话
- `context_type`：上下文类型（会话上下文、用户上下文、系统上下文）
- `context_data`：上下文数据，以JSON格式存储（包含对话历史、用户偏好、系统状态等）
- `expires_at`：上下文过期时间（可选，用于自动清理过期上下文）
- `created_at`：创建时间
- `updated_at`：更新时间

**注意：**
- FastMCP主要用于管理运行时上下文，此表用于持久化上下文状态
- 大部分上下文数据在内存中管理，此表用于跨会话恢复和持久化

### 4.7 用户设置表 (user_settings)

```sql
CREATE TABLE user_settings (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
    theme VARCHAR(20) DEFAULT 'dark',    -- 主题：'dark' 或 'light'
    language VARCHAR(10) DEFAULT 'zh-CN', -- 语言设置
    notifications JSONB,                  -- 通知设置（JSON格式）
    preferences JSONB,                    -- 用户偏好设置（JSON格式）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**字段说明：**
- `id`：主键
- `user_id`：外键，关联用户，唯一
- `theme`：主题设置（'dark'、'light'）
- `language`：语言设置（'zh-CN'、'en-US'等）
- `notifications`：通知设置，JSON格式（如邮件通知、推送通知等）
- `preferences`：用户偏好，JSON格式（如默认模型、温度参数等）
- `created_at`：创建时间
- `updated_at`：更新时间

### 4.8 文件附件表 (attachments)

```sql
CREATE TABLE attachments (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    message_id INTEGER REFERENCES messages(id) ON DELETE SET NULL,
    file_name VARCHAR(255) NOT NULL,     -- 原始文件名
    file_path VARCHAR(500) NOT NULL,      -- 存储路径
    file_type VARCHAR(100),               -- 文件类型（MIME类型）
    file_size BIGINT,                     -- 文件大小（字节）
    storage_type VARCHAR(50) DEFAULT 'local', -- 存储类型：'local'、's3'、'oss'等
    metadata JSONB,                       -- 文件元数据（JSON格式）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_attachments_user ON attachments(user_id);
CREATE INDEX idx_attachments_message ON attachments(message_id);
```

**字段说明：**
- `id`：主键
- `user_id`：外键，关联用户
- `message_id`：外键，关联消息（可选，可能用于其他用途）
- `file_name`：原始文件名
- `file_path`：文件存储路径或URL
- `file_type`：文件MIME类型（如'image/png'、'text/plain'）
- `file_size`：文件大小（字节）
- `storage_type`：存储类型（本地存储、对象存储等）
- `metadata`：文件元数据，JSON格式（如图片尺寸、文档页数等）
- `created_at`：创建时间

### 4.9 操作日志表 (operation_logs)

```sql
CREATE TABLE operation_logs (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
    operation_type VARCHAR(50) NOT NULL,   -- 操作类型：'login'、'logout'、'create_conversation'等
    resource_type VARCHAR(50),             -- 资源类型：'conversation'、'memory'等
    resource_id INTEGER,                   -- 资源ID
    ip_address VARCHAR(45),                -- IP地址
    user_agent TEXT,                       -- User-Agent
    details JSONB,                         -- 操作详情（JSON格式）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_logs_user ON operation_logs(user_id, created_at DESC);
CREATE INDEX idx_logs_type ON operation_logs(operation_type, created_at DESC);
CREATE INDEX idx_logs_resource ON operation_logs(resource_type, resource_id);
```

**字段说明：**
- `id`：主键
- `user_id`：外键，关联用户（可为空，用于匿名操作）
- `operation_type`：操作类型（'login'、'logout'、'create_conversation'、'delete_memory'等）
- `resource_type`：资源类型（'conversation'、'memory'、'message'等）
- `resource_id`：资源ID
- `ip_address`：IP地址
- `user_agent`：User-Agent字符串
- `details`：操作详情，JSON格式（如操作参数、结果等）
- `created_at`：创建时间

**用途：**
- 安全审计
- 用户行为分析
- 问题排查
- 数据恢复

---

## 五、前后端接口设计

### 5.0 接口设计规范

#### 5.0.1 统一响应格式

**成功响应格式：**
```json
{
  "success": true,
  "message": "操作成功",
  "data": {
    // 具体数据
  },
  "timestamp": "2024-01-01T12:00:00Z"
}
```

**错误响应格式：**
```json
{
  "success": false,
  "message": "错误描述",
  "error_code": "ERROR_CODE",
  "errors": [
    {
      "field": "username",
      "message": "用户名不能为空"
    }
  ],
  "timestamp": "2024-01-01T12:00:00Z"
}
```

#### 5.0.2 HTTP状态码使用

- `200 OK`：请求成功
- `201 Created`：资源创建成功
- `400 Bad Request`：请求参数错误
- `401 Unauthorized`：未认证或token无效
- `403 Forbidden`：无权限访问
- `404 Not Found`：资源不存在
- `409 Conflict`：资源冲突（如用户名已存在）
- `422 Unprocessable Entity`：请求格式正确但语义错误
- `429 Too Many Requests`：请求频率过高
- `500 Internal Server Error`：服务器内部错误

#### 5.0.3 错误码定义

| 错误码 | 说明 | HTTP状态码 |
|--------|------|-----------|
| `VALIDATION_ERROR` | 验证错误 | 400 |
| `UNAUTHORIZED` | 未认证 | 401 |
| `FORBIDDEN` | 无权限 | 403 |
| `NOT_FOUND` | 资源不存在 | 404 |
| `USERNAME_EXISTS` | 用户名已存在 | 409 |
| `EMAIL_EXISTS` | 邮箱已存在 | 409 |
| `INVALID_CREDENTIALS` | 用户名或密码错误 | 401 |
| `TOKEN_EXPIRED` | Token已过期 | 401 |
| `TOKEN_INVALID` | Token无效 | 401 |
| `RATE_LIMIT_EXCEEDED` | 请求频率过高 | 429 |
| `INTERNAL_ERROR` | 服务器内部错误 | 500 |

#### 5.0.4 分页参数

**查询参数：**
- `page`：页码，从1开始，默认1
- `limit`：每页数量，默认20，最大100
- `sort`：排序字段，如`created_at`、`updated_at`
- `order`：排序方向，`asc`或`desc`，默认`desc`

**分页响应：**
```json
{
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 100,
    "total_pages": 5,
    "has_next": true,
    "has_prev": false
  }
}
```

#### 5.0.5 请求验证规则

**用户名：**
- 长度：3-50个字符
- 格式：字母、数字、下划线、连字符
- 不能以数字开头

**邮箱：**
- 符合标准邮箱格式
- 长度：不超过100个字符

**密码：**
- 长度：至少8个字符
- 建议包含：大小写字母、数字、特殊字符

**对话标题：**
- 长度：不超过200个字符

**消息内容：**
- 不能为空
- 长度：不超过10000个字符

---

### 5.1 认证相关接口

#### 5.1.1 用户注册

**接口信息：**
- **URL：** `POST /api/auth/register`
- **认证：** 无需认证
- **Content-Type：** `application/json`

**前端请求：**
```typescript
// 前端调用示例
const registerUser = async (username: string, email: string, password: string) => {
  const response = await axios.post('/api/auth/register', {
    username,
    email,
    password
  });
  return response.data;
};
```

**请求体：**
```json
{
  "username": "user123",
  "email": "user@example.com",
  "password": "password123"
}
```

**后端处理流程：**
1. 验证请求数据（用户名、邮箱格式、密码强度）
2. 检查用户名和邮箱是否已存在
3. 使用bcrypt加密密码
4. 创建用户记录到数据库
5. 返回成功响应

**响应：**
```json
{
  "success": true,
  "message": "注册成功",
  "data": {
    "user_id": 1,
    "username": "user123",
    "email": "user@example.com"
  }
}
```

**错误响应示例：**

1. **用户名已存在：**
```json
{
  "success": false,
  "message": "用户名已存在",
  "error_code": "USERNAME_EXISTS",
  "timestamp": "2024-01-01T12:00:00Z"
}
```

2. **邮箱已存在：**
```json
{
  "success": false,
  "message": "邮箱已被注册",
  "error_code": "EMAIL_EXISTS",
  "timestamp": "2024-01-01T12:00:00Z"
}
```

3. **验证错误：**
```json
{
  "success": false,
  "message": "请求参数验证失败",
  "error_code": "VALIDATION_ERROR",
  "errors": [
    {
      "field": "username",
      "message": "用户名长度必须在3-50个字符之间"
    },
    {
      "field": "password",
      "message": "密码长度至少8个字符"
    }
  ],
  "timestamp": "2024-01-01T12:00:00Z"
}
```

#### 5.1.2 用户登录

**接口信息：**
- **URL：** `POST /api/auth/login`
- **认证：** 无需认证
- **Content-Type：** `application/json`

**前端请求：**
```typescript
const login = async (username: string, password: string) => {
  const response = await axios.post('/api/auth/login', {
    username,
    password
  });
  // 存储token到localStorage
  localStorage.setItem('token', response.data.data.access_token);
  return response.data;
};
```

**请求体：**
```json
{
  "username": "user123",
  "password": "password123"
}
```

**后端处理流程：**
1. 验证请求数据格式
2. 查询用户（支持用户名或邮箱登录）
3. 验证密码（使用bcrypt比较）
4. 更新用户最后登录时间
5. 生成JWT token（包含用户ID、过期时间）
6. 记录登录日志
7. 返回token和用户信息

**错误响应：**
1. **用户名或密码错误：**
```json
{
  "success": false,
  "message": "用户名或密码错误",
  "error_code": "INVALID_CREDENTIALS",
  "timestamp": "2024-01-01T12:00:00Z"
}
```

2. **账户未激活：**
```json
{
  "success": false,
  "message": "账户未激活，请先验证邮箱",
  "error_code": "ACCOUNT_INACTIVE",
  "timestamp": "2024-01-01T12:00:00Z"
}
```

**响应：**
```json
{
  "success": true,
  "message": "登录成功",
  "data": {
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
    "token_type": "Bearer",
    "expires_in": 3600,
    "user": {
      "id": 1,
      "username": "user123",
      "email": "user@example.com"
    }
  }
}
```

#### 5.1.3 获取当前用户信息

**接口信息：**
- **URL：** `GET /api/auth/me`
- **认证：** 需要Bearer Token
- **Headers：** `Authorization: Bearer <token>`

**前端请求：**
```typescript
const getCurrentUser = async () => {
  const token = localStorage.getItem('token');
  const response = await axios.get('/api/auth/me', {
    headers: { Authorization: `Bearer ${token}` }
  });
  return response.data;
};
```

**响应：**
```json
{
  "success": true,
  "data": {
    "id": 1,
    "username": "user123",
    "email": "user@example.com",
    "avatar_url": "https://example.com/avatar.jpg",
    "bio": "个人简介",
    "is_email_verified": true,
    "created_at": "2024-01-01T12:00:00Z"
  }
}
```

#### 5.1.4 更新用户信息

**接口信息：**
- **URL：** `PUT /api/auth/me`
- **认证：** 需要Bearer Token

**请求体：**
```json
{
  "username": "newusername",
  "bio": "新的个人简介",
  "avatar_url": "https://example.com/new-avatar.jpg"
}
```

**响应：**
```json
{
  "success": true,
  "message": "用户信息更新成功",
  "data": {
    "id": 1,
    "username": "newusername",
    "email": "user@example.com",
    "bio": "新的个人简介",
    "avatar_url": "https://example.com/new-avatar.jpg",
    "updated_at": "2024-01-01T13:00:00Z"
  }
}
```

#### 5.1.5 修改密码

**接口信息：**
- **URL：** `PUT /api/auth/password`
- **认证：** 需要Bearer Token

**请求体：**
```json
{
  "old_password": "oldpassword123",
  "new_password": "newpassword123"
}
```

**错误响应：**
```json
{
  "success": false,
  "message": "原密码错误",
  "error_code": "INVALID_PASSWORD",
  "timestamp": "2024-01-01T12:00:00Z"
}
```

#### 5.1.6 刷新Token

**接口信息：**
- **URL：** `POST /api/auth/refresh`
- **认证：** 需要Bearer Token（使用refresh token）

**响应：**
```json
{
  "success": true,
  "data": {
    "access_token": "new_token_here",
    "token_type": "Bearer",
    "expires_in": 3600
  }
}
```

---

### 5.2 对话相关接口

#### 5.2.1 获取对话列表

**接口信息：**
- **URL：** `GET /api/conversations`
- **认证：** 需要Bearer Token
- **查询参数：** `?page=1&limit=20`

**前端请求：**
```typescript
const getConversations = async (page = 1, limit = 20) => {
  const response = await axios.get(`/api/conversations?page=${page}&limit=${limit}`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  return response.data;
};
```

**后端处理流程：**
1. 验证token，获取用户ID
2. 从数据库查询该用户的所有对话
3. 按更新时间倒序排列
4. 分页返回

**响应：**
```json
{
  "success": true,
  "data": {
    "conversations": [
      {
        "id": 1,
        "title": "关于Python的问题",
        "created_at": "2024-01-01T12:00:00Z",
        "updated_at": "2024-01-01T13:00:00Z",
        "message_count": 10
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 5,
      "total_pages": 1
    }
  }
}
```

#### 5.2.2 创建对话

**接口信息：**
- **URL：** `POST /api/conversations`
- **认证：** 需要Bearer Token

**前端请求：**
```typescript
const createConversation = async (title?: string) => {
  const response = await axios.post('/api/conversations', {
    title: title || '新对话'
  }, {
    headers: { Authorization: `Bearer ${token}` }
  });
  return response.data;
};
```

**请求体：**
```json
{
  "title": "新对话"
}
```

**响应：**
```json
{
  "success": true,
  "data": {
    "id": 1,
    "title": "新对话",
    "created_at": "2024-01-01T12:00:00Z"
  }
}
```

#### 5.2.3 发送消息（核心接口 - 调用智能体）

**接口信息：**
- **URL：** `POST /api/conversations/{conversation_id}/messages`
- **认证：** 需要Bearer Token
- **Content-Type：** `application/json`

**前端请求：**
```typescript
const sendMessage = async (conversationId: number, content: string) => {
  const response = await axios.post(
    `/api/conversations/${conversationId}/messages`,
    { content },
    {
      headers: { Authorization: `Bearer ${token}` }
    }
  );
  return response.data;
};
```

**请求体：**
```json
{
  "content": "什么是Python？"
}
```

**后端处理流程（详细）：**
1. **验证和准备：**
   - 验证token，获取用户ID
   - 验证对话是否存在且属于该用户
   - 保存用户消息到数据库

2. **准备上下文：**
   - 从数据库获取该对话的历史消息（最近N条）
   - 从数据库获取用户的相关记忆（可选）

3. **调用智能体服务：**
   ```python
   # 后端调用智能体服务
   agent_response = agent_service.process_message(
       user_id=user_id,
       conversation_id=conversation_id,
       message=user_message,
       context={
           "history": conversation_history,
           "memories": relevant_memories
       }
   )
   ```

4. **保存和返回：**
   - 保存智能体的回答到数据库
   - 返回完整的消息对（用户消息 + AI回答）

**响应：**
```json
{
  "success": true,
  "data": {
    "user_message": {
      "id": 1,
      "content": "什么是Python？",
      "role": "user",
      "created_at": "2024-01-01T12:00:00Z"
    },
    "assistant_message": {
      "id": 2,
      "content": "Python是一种高级编程语言...",
      "role": "assistant",
      "created_at": "2024-01-01T12:00:01Z"
    }
  }
}
```

#### 5.2.4 流式发送消息（Server-Sent Events）

**接口信息：**
- **URL：** `POST /api/conversations/{conversation_id}/messages/stream`
- **认证：** 需要Bearer Token
- **Content-Type：** `application/json`
- **响应类型：** `text/event-stream`
- **Accept：** `text/event-stream`

**前端请求：**
```typescript
const sendMessageStream = async (conversationId: number, content: string) => {
  const eventSource = new EventSourcePolyfill(
    `/api/conversations/${conversationId}/messages/stream`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ content })
    }
  );

  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (data.type === 'token') {
      // 实时显示token
      updateMessageContent(data.content);
    } else if (data.type === 'done') {
      // 完成
      eventSource.close();
    }
  };
};
```

**SSE事件格式：**
```
event: token
data: {"type":"token","content":"Python"}

event: token
data: {"type":"token","content":"是一种"}

event: done
data: {"type":"done","message_id":123}
```

**错误处理：**
```
event: error
data: {"type":"error","message":"生成失败","error_code":"GENERATION_FAILED"}
```

#### 5.2.5 获取对话历史

**接口信息：**
- **URL：** `GET /api/conversations/{conversation_id}/messages`
- **认证：** 需要Bearer Token
- **查询参数：** `?page=1&limit=50`

**前端请求：**
```typescript
const getMessages = async (conversationId: number, page = 1) => {
  const response = await axios.get(
    `/api/conversations/${conversationId}/messages?page=${page}&limit=50`,
    { headers: { Authorization: `Bearer ${token}` } }
  );
  return response.data;
};
```

**响应：**
```json
{
  "success": true,
  "data": {
    "messages": [
      {
        "id": 1,
        "role": "user",
        "content": "什么是Python？",
        "created_at": "2024-01-01T12:00:00Z"
      },
      {
        "id": 2,
        "role": "assistant",
        "content": "Python是一种高级编程语言...",
        "created_at": "2024-01-01T12:00:01Z"
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 50,
      "total": 2
    }
  }
}
```

#### 5.2.6 更新对话

**接口信息：**
- **URL：** `PUT /api/conversations/{conversation_id}`
- **认证：** 需要Bearer Token

**请求体：**
```json
{
  "title": "新的对话标题",
  "description": "对话描述",
  "is_pinned": true,
  "is_archived": false,
  "settings": {
    "model": "gpt-4",
    "temperature": 0.7
  }
}
```

**响应：**
```json
{
  "success": true,
  "message": "对话更新成功",
  "data": {
    "id": 1,
    "title": "新的对话标题",
    "description": "对话描述",
    "is_pinned": true,
    "is_archived": false,
    "updated_at": "2024-01-01T14:00:00Z"
  }
}
```

#### 5.2.7 删除对话

**接口信息：**
- **URL：** `DELETE /api/conversations/{conversation_id}`
- **认证：** 需要Bearer Token

**响应：**
```json
{
  "success": true,
  "message": "对话删除成功"
}
```

**错误响应：**
```json
{
  "success": false,
  "message": "对话不存在或无权限",
  "error_code": "NOT_FOUND",
  "timestamp": "2024-01-01T12:00:00Z"
}
```

#### 5.2.8 批量删除对话

**接口信息：**
- **URL：** `DELETE /api/conversations/batch`
- **认证：** 需要Bearer Token

**请求体：**
```json
{
  "conversation_ids": [1, 2, 3]
}
```

#### 5.2.9 更新消息

**接口信息：**
- **URL：** `PUT /api/conversations/{conversation_id}/messages/{message_id}`
- **认证：** 需要Bearer Token

**请求体：**
```json
{
  "content": "编辑后的消息内容"
}
```

#### 5.2.10 删除消息

**接口信息：**
- **URL：** `DELETE /api/conversations/{conversation_id}/messages/{message_id}`
- **认证：** 需要Bearer Token

---

### 5.3 记忆数据相关接口

#### 5.3.1 获取记忆列表

**接口信息：**
- **URL：** `GET /api/memories`
- **认证：** 需要Bearer Token
- **查询参数：** `?page=1&limit=20&category=工作&search=关键词`

**前端请求：**
```typescript
const getMemories = async (filters: {
  page?: number;
  limit?: number;
  category?: string;
  search?: string;
}) => {
  const params = new URLSearchParams();
  if (filters.page) params.append('page', filters.page.toString());
  if (filters.limit) params.append('limit', filters.limit.toString());
  if (filters.category) params.append('category', filters.category);
  if (filters.search) params.append('search', filters.search);
  
  const response = await axios.get(`/api/memories?${params}`, {
    headers: { Authorization: `Bearer ${token}` }
  });
  return response.data;
};
```

**后端处理流程：**
1. 验证token，获取用户ID
2. 从数据库查询该用户的记忆
3. 应用筛选条件（分类、搜索）
4. 如果使用语义搜索，调用智能体服务的搜索接口
5. 分页返回

**响应：**
```json
{
  "success": true,
  "data": {
    "memories": [
      {
        "id": 1,
        "title": "工作项目",
        "content": "需要完成Python项目",
        "category": "工作",
        "tags": ["重要", "待办"],
        "created_at": "2024-01-01T12:00:00Z",
        "updated_at": "2024-01-01T12:00:00Z"
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 10
    }
  }
}
```

#### 5.3.2 创建记忆

**接口信息：**
- **URL：** `POST /api/memories`
- **认证：** 需要Bearer Token

**前端请求：**
```typescript
const createMemory = async (memory: {
  title: string;
  content: string;
  category?: string;
  tags?: string[];
}) => {
  const response = await axios.post('/api/memories', memory, {
    headers: { Authorization: `Bearer ${token}` }
  });
  return response.data;
};
```

**请求体：**
```json
{
  "title": "工作项目",
  "content": "需要完成Python项目，截止日期是下周五",
  "category": "工作",
  "tags": ["重要", "待办"]
}
```

**后端处理流程：**
1. 验证token和数据
2. 保存记忆元数据到PostgreSQL
3. 调用智能体服务，将记忆同步到智能体系统（Mem0）
4. 返回创建的记忆

**响应：**
```json
{
  "success": true,
  "data": {
    "id": 1,
    "title": "工作项目",
    "content": "需要完成Python项目，截止日期是下周五",
    "category": "工作",
    "tags": ["重要", "待办"],
    "created_at": "2024-01-01T12:00:00Z"
  }
}
```

#### 5.3.3 更新记忆

**接口信息：**
- **URL：** `PUT /api/memories/{memory_id}`
- **认证：** 需要Bearer Token

#### 5.3.4 删除记忆

**接口信息：**
- **URL：** `DELETE /api/memories/{memory_id}`
- **认证：** 需要Bearer Token

**后端处理流程：**
1. 验证token和记忆所有权
2. 从PostgreSQL删除记忆
3. 调用智能体服务，从智能体系统删除记忆
4. 返回成功响应

#### 5.3.5 搜索记忆（语义搜索）

**接口信息：**
- **URL：** `POST /api/memories/search`
- **认证：** 需要Bearer Token

**请求体：**
```json
{
  "query": "关于Python的项目",
  "limit": 10
}
```

**后端处理流程：**
1. 验证token
2. 调用智能体服务的语义搜索接口
3. 返回相关记忆列表

---

### 5.4 后端与智能体服务的接口

**说明：** 后端通过服务接口调用智能体，智能体内部实现对后端透明。

**接口定义（示例）：**

```python
# app/services/agent_service.py
class AgentService:
    def process_message(self, user_id, conversation_id, message, context):
        """
        处理用户消息，调用智能体生成回答
        
        参数：
        - user_id: 用户ID
        - conversation_id: 对话ID
        - message: 用户消息内容
        - context: 上下文数据（对话历史、记忆等）
        
        返回：
        - assistant_message: AI回答
        """
        # 调用智能体服务（内部使用Mem0、FastMCP）
        # 返回AI回答
        pass
    
    def sync_memory(self, user_id, memory_data):
        """
        同步记忆到智能体系统
        
        参数：
        - user_id: 用户ID
        - memory_data: 记忆数据
        
        返回：
        - success: 是否成功
        """
        # 调用智能体服务，同步记忆（Mem0）
        pass
    
    def search_memories(self, user_id, query, limit=10):
        """
        语义搜索记忆
        
        参数：
        - user_id: 用户ID
        - query: 搜索查询
        - limit: 返回数量限制
        
        返回：
        - memories: 相关记忆列表
        """
        # 调用智能体服务，进行语义搜索
        pass
```

---

## 六、主要功能实现要点

### 6.1 用户认证功能

#### 6.1.1 后端实现

**密码加密：**
- 使用 `bcrypt` 库进行密码哈希
- 存储哈希值，不存储明文密码

**JWT Token管理：**
- 使用 `Flask-JWT-Extended` 生成和验证token
- Token包含用户ID和过期时间
- 创建认证装饰器保护需要认证的路由

**实现示例：**
```python
# app/utils/auth.py
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity

def generate_token(user_id):
    return create_access_token(identity=user_id)

@jwt_required()
def get_current_user():
    user_id = get_jwt_identity()
    return User.query.get(user_id)
```

#### 6.1.2 前端实现

**Token存储：**
- 登录成功后，将token存储到localStorage
- 每次API请求时，在Header中携带token
- 实现token过期自动刷新或重新登录

**实际实现：**
```typescript
// frontend/src/api.ts
const API_BASE = '/api';

function getAuthToken(): string | null {
  return localStorage.getItem('token');
}

function setAuthToken(token: string | null): void {
  if (token) {
    localStorage.setItem('token', token);
  } else {
    localStorage.removeItem('token');
  }
}

async function request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const url = `${API_BASE}${endpoint}`;
  const headers: HeadersInit = {
    ...options.headers,
  };

  const token = getAuthToken();
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  if (options.body && typeof options.body === 'string') {
    headers['Content-Type'] = 'application/json';
  }

  const response = await fetch(url, {
    ...options,
    headers,
  });

  const data = await response.json();

  if (!response.ok) {
    if (response.status === 401) {
      setAuthToken(null);
      window.location.href = '/login';
    }
    throw new Error(data.message || '请求失败');
  }

  return data.data || data;
}
```

**说明：**
- 使用原生Fetch API替代Axios，减少依赖
- 在`request`函数中统一处理token和错误
- Token存储在localStorage中

### 6.2 对话交互功能

#### 6.2.1 后端实现

**核心流程：**
1. 接收用户消息
2. 验证用户和对话权限
3. 保存用户消息到数据库
4. 准备上下文（对话历史、相关记忆）
5. 调用智能体服务接口
6. 保存AI回答到数据库
7. 返回结果

**实现示例：**
```python
# app/services/conversation_service.py
class ConversationService:
    def send_message(self, user_id, conversation_id, message_content):
        # 1. 验证对话属于该用户
        conversation = Conversation.query.filter_by(
            id=conversation_id, user_id=user_id
        ).first_or_404()
        
        # 2. 保存用户消息
        user_msg = Message(
            conversation_id=conversation_id,
            role='user',
            content=message_content
        )
        db.session.add(user_msg)
        db.session.flush()
        
        # 3. 获取对话历史（最近20条）
        history = Message.query.filter_by(
            conversation_id=conversation_id
        ).order_by(Message.created_at.desc()).limit(20).all()
        history.reverse()
        
        # 4. 调用智能体服务
        agent_response = agent_service.process_message(
            user_id=user_id,
            conversation_id=conversation_id,
            message=message_content,
            context={'history': [{'role': m.role, 'content': m.content} for m in history]}
        )
        
        # 5. 保存AI回答
        assistant_msg = Message(
            conversation_id=conversation_id,
            role='assistant',
            content=agent_response
        )
        db.session.add(assistant_msg)
        db.session.commit()
        
        return {
            'user_message': user_msg,
            'assistant_message': assistant_msg
        }
```

#### 6.2.2 前端实现

**对话界面组件：**
- 消息列表组件：显示对话历史
- 消息输入组件：输入框、发送按钮
- 加载状态：发送消息时显示加载动画

**实现示例：**
```typescript
// src/components/Chat/ChatWindow.tsx
const ChatWindow: React.FC<{ conversationId: number }> = ({ conversationId }) => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [loading, setLoading] = useState(false);
  
  const sendMessage = async () => {
    if (!inputValue.trim()) return;
    
    setLoading(true);
    try {
      const response = await conversationService.sendMessage(
        conversationId,
        inputValue
      );
      // 添加新消息到列表
      setMessages(prev => [
        ...prev,
        response.data.user_message,
        response.data.assistant_message
      ]);
      setInputValue('');
    } catch (error) {
      console.error('发送消息失败', error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="chat-window">
      <MessageList messages={messages} />
      <MessageInput
        value={inputValue}
        onChange={setInputValue}
        onSend={sendMessage}
        loading={loading}
      />
    </div>
  );
};
```

### 6.3 记忆数据管理功能

#### 6.3.1 后端实现

**记忆CRUD操作：**
- 创建记忆：保存到PostgreSQL，同步到智能体系统
- 查询记忆：支持分页、筛选、搜索
- 更新记忆：更新PostgreSQL和智能体系统
- 删除记忆：从PostgreSQL和智能体系统删除

**实现示例：**
```python
# app/services/memory_service.py
class MemoryService:
    def create_memory(self, user_id, memory_data):
        # 1. 保存到PostgreSQL
        memory = Memory(
            user_id=user_id,
            title=memory_data['title'],
            content=memory_data['content'],
            category=memory_data.get('category'),
            tags=memory_data.get('tags', [])
        )
        db.session.add(memory)
        db.session.flush()
        
        # 2. 同步到智能体系统（Mem0）
        agent_service.sync_memory(user_id, {
            'id': memory.id,
            'content': memory.content,
            'metadata': {
                'title': memory.title,
                'category': memory.category,
                'tags': memory.tags
            }
        })
        
        db.session.commit()
        return memory
    
    def search_memories(self, user_id, query, filters=None):
        # 1. 关键词搜索（PostgreSQL）
        memories = Memory.query.filter_by(user_id=user_id)
        
        if filters and filters.get('category'):
            memories = memories.filter_by(category=filters['category'])
        
        if filters and filters.get('search'):
            memories = memories.filter(
                Memory.content.contains(filters['search'])
            )
        
        # 2. 语义搜索（通过智能体服务）
        if filters and filters.get('semantic_search'):
            semantic_results = agent_service.search_memories(
                user_id, query, limit=10
            )
            # 合并结果
            pass
        
        return memories.paginate(
            page=filters.get('page', 1),
            per_page=filters.get('limit', 20)
        )
```

#### 6.3.2 前端实现

**记忆管理界面：**
- 记忆列表：卡片式展示，支持筛选和搜索
- 记忆编辑器：创建和编辑记忆
- 记忆详情：查看记忆详情

**实现示例：**
```typescript
// src/components/Memory/MemoryList.tsx
const MemoryList: React.FC = () => {
  const [memories, setMemories] = useState<Memory[]>([]);
  const [filters, setFilters] = useState({
    page: 1,
    limit: 20,
    category: '',
    search: ''
  });
  
  useEffect(() => {
    loadMemories();
  }, [filters]);
  
  const loadMemories = async () => {
    const response = await memoryService.getMemories(filters);
    setMemories(response.data.memories);
  };
  
  return (
    <div className="memory-list">
      <MemoryFilters filters={filters} onChange={setFilters} />
      <div className="memory-cards">
        {memories.map(memory => (
          <MemoryCard key={memory.id} memory={memory} />
        ))}
      </div>
      <Pagination
        current={filters.page}
        total={response.data.pagination.total}
        onChange={(page) => setFilters({ ...filters, page })}
      />
    </div>
  );
};
```

### 6.4 后端与智能体服务的交互

**说明：** 后端通过服务接口调用智能体，智能体内部实现（Mem0、FastMCP）对后端透明。

**接口调用示例：**
```python
# app/services/agent_service.py
class AgentService:
    def __init__(self):
        # 初始化智能体服务客户端
        # 智能体服务可以是：
        # 1. 同一进程内的服务类
        # 2. 独立的HTTP服务
        # 3. gRPC服务
        pass
    
    def process_message(self, user_id, conversation_id, message, context):
        """
        调用智能体处理消息
        
        智能体内部会：
        - 使用FastMCP管理上下文
        - 使用Mem0检索相关记忆
        - 生成AI回答
        - 使用Mem0存储新记忆
        
        后端不需要关心这些细节
        """
        # 调用智能体服务
        response = self.agent_client.process(
            user_id=user_id,
            conversation_id=conversation_id,
            message=message,
            context=context
        )
        return response['assistant_message']
    
    def sync_memory(self, user_id, memory_data):
        """同步记忆到智能体系统"""
        return self.agent_client.sync_memory(
            user_id=user_id,
            memory=memory_data
        )
    
    def search_memories(self, user_id, query, limit=10):
        """语义搜索记忆"""
        return self.agent_client.search_memories(
            user_id=user_id,
            query=query,
            limit=limit
        )
```

---

## 七、开发环境配置

### 7.1 后端环境

**Python版本：** Python 3.9+

**依赖包：**
```
# Web框架
Flask==3.0.0
Flask-RESTful==0.3.10
Flask-SQLAlchemy==3.1.1
Flask-JWT-Extended==4.6.0
Flask-CORS==4.0.0

# 数据库
psycopg2-binary==2.9.9
pgvector==0.2.4  # PostgreSQL向量扩展（可选）

# 认证和安全
bcrypt==4.1.2

# Mem0记忆管理
mem0ai==1.0.0  # Mem0 Python SDK
qdrant-client==1.7.0  # Qdrant向量数据库客户端（如果使用Qdrant）
# pinecone-client==3.0.0  # Pinecone客户端（如果使用Pinecone）
# weaviate-client==4.4.0  # Weaviate客户端（如果使用Weaviate）

# FastMCP
fastmcp==0.1.0  # FastMCP框架（根据实际包名调整）
# 或使用 mcp==0.1.0  # 如果FastMCP的包名不同

# OpenAI SDK（Mem0需要）
openai==1.12.0

# 工具库
python-dotenv==1.0.0
pydantic==2.5.0  # 数据验证
requests==2.31.0  # HTTP请求
```

**向量数据库选择：**

根据项目需求选择一种向量数据库：

1. **Qdrant（推荐用于开发）**：
   - 开源，可本地部署
   - 安装：`docker run -p 6333:6333 qdrant/qdrant`
   - 依赖：`qdrant-client`

2. **Pinecone（推荐用于生产）**：
   - 托管服务，易于使用
   - 需要注册账号获取API密钥
   - 依赖：`pinecone-client`

3. **Weaviate**：
   - 开源，功能强大
   - 支持图数据库功能
   - 依赖：`weaviate-client`

4. **PostgreSQL + pgvector（简单场景）**：
   - 如果数据量不大，可以直接使用PostgreSQL的pgvector扩展
   - 无需额外的向量数据库服务

### 7.2 前端环境

**Node.js版本：** Node.js 18+

**实际使用的依赖包（通过npm管理）：**
```json
{
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^6.26.0",
    "react-markdown": "^9.0.1",
    "react-syntax-highlighter": "^15.5.0",
    "@types/react-syntax-highlighter": "^15.5.13"
  },
  "devDependencies": {
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "typescript": "~5.9.3",
    "vite": "^7.2.4",
    "eslint": "^9.39.1"
  }
}
```

**说明：**
- 使用`npm`作为包管理器
- 使用Vite作为构建工具（替代Create React App）
- 使用原生Fetch API（替代Axios）
- 使用react-markdown和react-syntax-highlighter实现Markdown渲染和代码高亮
- 未使用UI组件库（Ant Design等），完全自定义UI
- 未使用状态管理库（Redux等），使用React Hooks管理状态

### 7.3 数据库环境

**PostgreSQL版本：** PostgreSQL 14+

**配置：**
- 创建数据库和用户
- 配置连接参数（host, port, database, user, password）

---

## 八、部署方案

### 8.1 开发环境

- **后端：** Flask开发服务器（`flask run`）
- **前端：** React开发服务器（`npm start`）
- **数据库：** PostgreSQL本地实例或Docker容器

### 8.2 生产环境

**后端部署：**
- 使用 `Gunicorn` 或 `uWSGI` 作为WSGI服务器
- 使用 `Nginx` 作为反向代理
- 使用 `Supervisor` 或 `systemd` 管理进程

**前端部署：**
- 构建生产版本（`npm run build`）
- 使用Nginx提供静态文件服务
- 配置API代理

**数据库：**
- PostgreSQL生产实例
- 配置备份策略
- 监控数据库性能

---

## 九、安全考虑

### 9.1 认证安全
- 密码使用bcrypt加密
- JWT token设置合理的过期时间
- 使用HTTPS传输

### 9.2 数据安全
- SQL注入防护（使用ORM）
- XSS防护（前端输入验证和转义）
- CSRF防护（使用token）

### 9.3 API安全
- 请求频率限制（Rate Limiting）
- 输入验证和清理
- 错误信息不暴露敏感信息

---

## 十、总结

### 10.1 技术栈总结

| 层级 | 技术选型 | 版本要求 | 说明 |
|------|---------|---------|------|
| 后端框架 | Flask | 3.0+ | 轻量级Web框架 |
| API框架 | Flask-RESTful | 0.3+ | RESTful API开发 |
| ORM | SQLAlchemy | 2.0+ | 数据库ORM |
| 关系数据库 | PostgreSQL | 14+ | 主数据库 |
| 向量数据库 | Qdrant/Pinecone | - | Mem0记忆向量存储 |
| 图数据库 | Neo4j | - | 可选，实体关系存储 |
| 前端框架 | React | 18+ | 前端UI框架 |
| 类型系统 | TypeScript | 5.0+ | 类型安全 |
| 记忆管理 | Mem0 | 1.0+ | 智能记忆管理 |
| 上下文管理 | FastMCP | 0.1+ | 模型上下文协议 |
| 认证 | JWT | - | 用户认证 |

### 10.2 优势分析

1. **技术成熟**：所有选型都是经过市场验证的主流技术
2. **社区支持**：丰富的文档和社区资源
3. **易于维护**：清晰的架构和代码组织
4. **可扩展性**：模块化设计，易于扩展新功能
5. **开发效率**：成熟的工具链和最佳实践
6. **智能记忆**：Mem0提供专业的AI记忆管理，支持多层级记忆和语义检索
7. **上下文管理**：FastMCP提供高效的上下文传递和管理，提升Agent性能
8. **框架协同**：Mem0、FastMCP协同工作，形成完整的AI Agent解决方案
9. **灵活存储**：支持多种存储后端（关系数据库、向量数据库、图数据库），适应不同场景
10. **高性能**：FastMCP优化了上下文传递性能，Mem0的向量检索提供快速记忆查找

### 10.3 开发建议

1. **分阶段开发**：
   - 第一阶段：基础功能（用户认证、对话、基础记忆管理）
   - 第二阶段：集成Mem0（记忆存储和检索）
   - 第三阶段：集成FastMCP（上下文管理）
   - 第四阶段：优化和扩展功能

2. **API优先**：先完成后端API，再开发前端

3. **框架集成顺序**：
   - 先集成Mem0，实现记忆管理
   - 再集成FastMCP，优化上下文传递

4. **向量数据库选择**：
   - 开发阶段：使用Qdrant（本地部署，易于调试）
   - 生产阶段：根据需求选择Qdrant、Pinecone或Weaviate

5. **记忆管理策略**：
   - 开始时使用简单的记忆类型（episodic）
   - 逐步引入更复杂的记忆类型和关系
   - 定期评估和清理无用记忆

6. **上下文管理优化**：
   - 合理设置上下文大小限制
   - 使用缓存减少数据库查询
   - 定期清理过期上下文

7. **测试驱动**：
   - 编写单元测试（特别是Mem0和FastMCP的集成）
   - 编写集成测试（测试完整的Agent执行流程）
   - 测试记忆检索的准确性

8. **文档维护**：
   - 保持API文档和代码注释的更新
   - 记录Mem0和FastMCP的配置和使用方法
   - 维护记忆类型和上下文管理的文档

9. **代码规范**：
   - 遵循PEP 8（Python）和ESLint（TypeScript）规范
   - 使用类型提示（Python）和TypeScript类型定义

10. **性能监控**：
    - 监控向量检索性能
    - 监控上下文传递延迟
    - 监控记忆存储和检索的准确性

---

## 附录：快速开始

### A.1 后端初始化

```bash
# 创建虚拟环境
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# 安装依赖
pip install -r requirements.txt

# 配置环境变量
cp .env.example .env
# 编辑.env文件，配置以下内容：
# - 数据库连接（PostgreSQL）
# - OpenAI API密钥
# - 向量数据库配置（Qdrant/Pinecone）
# - JWT密钥
# - FastMCP配置

# 启动向量数据库（如果使用Qdrant）
docker run -d -p 6333:6333 -p 6334:6334 qdrant/qdrant

# 初始化数据库
flask db init
flask db migrate -m "Initial migration"
flask db upgrade

# 初始化Mem0（如果需要）
# 运行初始化脚本创建向量集合

# 启动服务
flask run
```

**环境变量配置示例（.env）：**

```env
# 数据库配置
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
# 开发环境可以使用SQLite
# DATABASE_URL=sqlite:///app.db

# LLM提供商配置（支持openai和deepseek）
LLM_PROVIDER=openai  # 或 'deepseek'

# OpenAI配置（如果使用OpenAI）
OPENAI_API_KEY=your_openai_api_key
LLM_MODEL=gpt-4o-mini

# DeepSeek配置（如果使用DeepSeek）
DEEPSEEK_API_KEY=your_deepseek_api_key
DEEPSEEK_BASE_URL=https://api.deepseek.com
# LLM_MODEL=deepseek-chat  # DeepSeek模型名称

# Mem0配置（必须保留）
MEM0_VECTOR_STORE=qdrant
QDRANT_URL=http://localhost:6333
QDRANT_COLLECTION=memories
MEM0_API_KEY=  # 如果使用Mem0托管服务，填写API密钥

# FastMCP配置（可选）
MCP_ENABLED=true
MCP_CACHE_SIZE=1000

# 外部智能体服务配置（本地部署的独立服务）
AGENT_SERVICE_URL=  # 本地部署的外部智能体服务地址，如: http://localhost:8000
AGENT_SERVICE_TIMEOUT=60
AGENT_INTEGRATED=false  # 是否已集成到项目（预留，未来集成后设置为true）

# 智能体配置
MAX_CONTEXT_LENGTH=4000
MAX_HISTORY_MESSAGES=20

# JWT配置
JWT_SECRET_KEY=your_secret_key
JWT_ACCESS_TOKEN_EXPIRES=3600

# Flask配置
FLASK_ENV=development
FLASK_DEBUG=True
SECRET_KEY=your-secret-key-change-in-production

# CORS配置
CORS_ORIGINS=http://localhost:3000
```

**配置说明：**
- **LLM提供商**：通过`LLM_PROVIDER`环境变量选择使用OpenAI或DeepSeek
- **外部智能体服务**：本地部署的独立服务，如果配置了`AGENT_SERVICE_URL`（如 `http://localhost:8000`），将调用外部智能体服务，否则使用本地LLM客户端
- **集成模式**：`AGENT_INTEGRATED`用于标识外部智能体服务是否已集成到项目（预留接口）
- **Mem0框架**：必须保留，用于记忆管理，支持本地部署或托管服务

### A.2 前端初始化

```bash
# 安装依赖
cd frontend
npm install

# 配置API地址（如需要）
# 编辑frontend/src/api.ts中的API_BASE常量
# 默认：const API_BASE = '/api'

# 启动开发服务器
npm run dev
# Vite开发服务器默认运行在 http://localhost:5173

# 构建生产版本
npm run build
# 构建产物在 frontend/dist 目录
```

**说明：**
- 使用Vite作为开发服务器和构建工具
- 开发服务器支持热模块替换（HMR）
- API地址通过`API_BASE`常量配置，默认使用相对路径`/api`

---

**文档版本：** v5.1  
**创建日期：** 2024年  
**最后更新：** 2024年  
**更新内容：** 
- **v5.1（当前版本）**：
  - **外部智能体服务本地部署**：明确外部智能体服务是本地部署的独立服务，未来可能集成到项目
  - **集成接口预留**：创建 `agent_service_interface.py` 定义接口规范，预留集成方法
  - **配置完善**：添加 `AGENT_INTEGRATED` 配置项，用于标识是否已集成到项目
  - **文档更新**：更新所有md文档，说明外部智能体服务的本地部署方式和集成接口预留
  
- **v5.0**：
  - **智能体服务接口适配层**：设计统一的接口适配层，支持外部智能体服务和本地实现两种模式
  - **DeepSeek API支持**：添加DeepSeek API兼容支持，可通过环境变量切换OpenAI/DeepSeek
  - **外部智能体服务接口规范**：定义外部智能体服务的HTTP接口规范（处理消息、流式输出、记忆同步等）
  - **Mem0框架集成**：保留Mem0框架，完善记忆同步、搜索、删除等接口
  - **配置优化**：更新环境变量配置，支持LLM提供商切换和外部智能体服务配置
  - **文档完善**：更新智能体服务框架说明，详细说明两种工作模式和接口规范
  
- **v4.0**：
  - 新增前端UI/UX设计部分，参考ChatGPT、Qwen等知名大模型网页设计
  - 完善数据库设计，新增用户设置表、文件附件表、操作日志表
  - 完善现有数据表，添加更多字段（头像、简介、置顶、归档等）
  - 新增接口设计规范（统一响应格式、错误码定义、分页规范等）
  - 完善认证接口，新增更新用户信息、修改密码、刷新Token等接口
  - 完善对话接口，新增流式响应、更新对话、批量删除、消息编辑等接口
  - 添加详细的错误处理和响应示例
  
- **v3.1**：
  - 删除所有LangChain相关内容
  - 简化智能体框架说明，仅保留Mem0和FastMCP
  - 更新依赖包列表，移除langchain相关包
  - 更新技术栈总结，移除LangChain条目
  
- **v3.0**：
  - 重构文档结构，聚焦前后端和接口交互
  - 详细展开API接口设计，包含前后端调用示例
  - 简化智能体内部实现细节，强调接口调用方式
  - 重点说明主要功能的前后端实现要点
  - 明确后端与智能体服务的接口定义
  
- **v2.0**：
  - 新增Mem0框架详细分析（智能记忆管理）
  - 新增FastMCP框架详细分析（模型上下文协议）
  - 更新系统架构设计，集成Mem0和FastMCP
  - 更新数据库设计，新增MCP上下文表
  - 更新开发环境配置，加入相关依赖

